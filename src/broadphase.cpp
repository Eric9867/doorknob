#include <algorithm>
#include "broadphase.h"
#include "geometry.h"

namespace door
{
static bool XCmp(const Geometry* a, const Geometry* b)
{
	return a->GetAABB().GetMin().x < b->GetAABB().GetMin().x;
}

static bool YCmp(const Geometry* a, const Geometry* b)
{
	return a->GetAABB().GetMin().y < b->GetAABB().GetMin().y;
}

static bool PairCmp(const std::pair<Geometry*, Geometry*> pair1, const std::pair<Geometry*, Geometry*> pair2)
{
	// compared by the pointers themselves
	if(pair1.first == pair2.first)
		return pair1.second < pair2.second;
	
	return pair1.first < pair2.first;
}

static bool IntervalOverlapX(const Geometry& geom_lower, const Geometry& geom_upper)
{
	return geom_lower.GetAABB().GetMax().x > geom_upper.GetAABB().GetMin().x; 
}

static bool IntervalOverlapY(const Geometry& geom_lower, const Geometry& geom_upper)
{
	return geom_lower.GetAABB().GetMax().y > geom_upper.GetAABB().GetMin().y; 
}

void SAPBroadPhase::Collide(const std::vector<Body>& bodies)
{
	// geometries of bodies are sorted based on AABBs
	// in m_axis_x and m_axis_y 
	m_axis_x.clear();
	m_axis_y.clear();
	for(const Body& body: bodies)
	{
		m_axis_x.push_back(&body.GetGeometry());
		m_axis_y.push_back(&body.GetGeometry());
	}
	std::sort(m_axis_x.begin(), m_axis_x.end(), XCmp);
	std::sort(m_axis_y.begin(), m_axis_y.end(), YCmp);
	
	// loop through and check for interval overlap
	
	//
	// x_axis
	//
	std::vector<std::pair<Geometry*, Geometry*>> x_coll;

	for(std::size_t i = 0; i < m_axis_x.size(); i++)
	{
		for(std::size_t j = i + 1; j < m_axis_x.size(); j++)
		{
			if(!IntervalOverlapX(*m_axis_x[i], *m_axis_x[j]))
				break;

			// always stores the smaller pointer as the first element of the pair for consistency
			// this ensure we can compare the pairs generated by scanning across the x and y axes
			// (where the order in which elements are added might vary)
			if(m_axis_x[i] < m_axis_x[j])
			{
				x_coll.push_back(std::make_pair(m_axis_x[i], m_axis_x[j]));
			} else {
				x_coll.push_back(std::make_pair(m_axis_x[j], m_axis_x[i]));
			}
		}	
	}

	//
	// y_axis
	//
	std::vector<std::pair<Geometry*, Geometry*>> y_coll;

	for(std::size_t i = 0; i < m_axis_y.size(); i++)
	{
		for(std::size_t j = i + 1; j < m_axis_y.size(); j++)
		{
			if(!IntervalOverlapY(*m_axis_y[i], *m_axis_y[j]))
				break;
			// always stores the smaller pointer as the first element of the pair for consistency
			// this ensure we can compare the pairs generated by scanning across the x and y axes
			// (where the order in which elements are added might vary)
			if(m_axis_y[i] < m_axis_y[j])
			{
				y_coll.push_back(std::make_pair(m_axis_y[i], m_axis_y[j]));
			} else {
				y_coll.push_back(std::make_pair(m_axis_y[j], m_axis_y[i]));
			}
		}	
	}

	// looking through both sets of collision candidate pairs and keeping those 
	// that exist in both
	std::sort(x_coll.begin(), x_coll.end(), PairCmp);
	std::sort(y_coll.begin(), y_coll.end(), PairCmp);
	std::vector<std::pair<Geometry*, Geometry*>> collision_candidates;
	std::size_t j = 0;

	for(std::size_t i = 0; i < x_coll.size(); i++)
	{
		// increment j as long as x_coll[i] > y_coll[j] 
		for(;!PairCmp(y_coll[j], x_coll[i]) && j < y_coll.size(); j++)
		{
			if(x_coll[i] == y_coll[j])
			{
				collision_candidates.push_back(x_coll[i]);
				j++;
				break;
			}
		}	
	}
}

} // namespace door
